---
date: 2015-10-04T23:51:18+09:00
from: hatenablog
title: cycle.jsを使うアプリのコード分割方針の例
---

<p>前の記事でcycle.jsについて少し紹介したものの、いまから始める人のことを考えると日本語の情報が無くて大変だろうと思ったので、何か説明出来ることがないか探した。多分使いはじめると途中でコードの分割方法について困ると思うので、いま開発しているエディタアプリではこうやっているよというのを書く。</p>

<h2>概観</h2>

<p>エディタ領域のコードは重いので左側2枚のサイドバーの部分のコードだけ抜き出して書くと、現状こういう感じのファイル構成になっている。</p>

<pre class="code" data-lang="" data-unlink>.
|-- entities
|   |-- sheet-group.js
|   `-- sheet.js
|-- index.html
|-- index.js
|-- intent.js
|-- intents
|   |-- load-sheet.js
|   `-- load-sheets.js
|-- model.js
|-- models
|   |-- panes-count.js
|   |-- sheet-group.js
|   |-- sheet-groups.js
|   `-- sheets.js
|-- templates
|   |-- root.js
|   |-- sheet-group-selector.js
|   `-- sheet-selector.js
`-- view.js</pre>


<p><img src="https://cloud.githubusercontent.com/assets/111689/10268419/0b883786-6af3-11e5-9a85-4c26ad156ae1.png" alt="image" /></p>

<h2>index.js</h2>

<p>このファイルが index.html から読み込まれるエントリポイントになる。同じディレクトリにある、Model・View・Intentの関数をそれぞれ読み込み、Cycle.jsのイベントループに設定するとアプリケーションが動き出す。index.js からは、出来る限りファイル構成がどうなっているかについて意識しなくても良いようにしようとしてこうなった。</p>

<pre class="code" data-lang="" data-unlink>import { makeDOMDriver } from &#39;@cycle/dom&#39;;
import Cycle, { Rx } from &#39;@cycle/core&#39;
import intent from &#39;./intent&#39;
import model from &#39;./model&#39;
import view from &#39;./view&#39;

Cycle.run(
  (responses) =&gt; {
    return {
      DOM: view(model(intent(responses)))
    };
  },
  {
    DOM: makeDOMDriver(&#39;body&#39;)
  }
);</pre>


<h2>intent.js</h2>

<p>intents ディレクトリの中にある小さく分割された<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4">複数</a>のintentを読み込み、大きなintentとして合成して返す。intentは「responsesを受け取って、<code>Object{String =&gt; Observable}</code> を返す関数」ということにしている。responsesは、<code>{ DOM: ... }</code> というデータ構造になっているObjectで、主にDOMからのイベントを受け取るためのイベントソースの集合である。DOM以外にもHTTPやipc (Electronのプロセス間通信のための仕組み) などから入力を受け取る場合もあるので、intentをresponsesを受け取る関数として定義した。intentは単純なObjectを返すだけなので簡単に1つの関数にまとめられる。</p>

<pre class="code" data-lang="" data-unlink>import loadSheet from &#39;./intents/load-sheet&#39;
import loadSheets from &#39;./intents/load-sheets&#39;

export default function (responses) {
  return {
    ...loadSheet(responses),
    ...loadSheets(responses)
  };
}</pre>


<h2>model.js</h2>

<p>modelsディレクトリの中にある小さく分割された<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4">複数</a>のmodelを読み込み、1つのストリームとして合成して返す。modelは「actionsを受け取り、<code>Observable&lt;Object&gt;</code> を返す関数」として定義したので、Rx.Observable.combineLatest で合成できる (どれか1つのObservableに新しい値が来たら新しい値を返すやつなので、これを使えば何らかの状態が更新されたときにViewに更新を伝えられる)。細かいけど、それぞれの分割されたmodel関数の名前は、その関数のObservableが返す値を表す名詞にしてみてる。しっくりこなかったら変える。</p>

<pre class="code" data-lang="" data-unlink>import _ from &#39;lodash&#39;
import { Rx } from &#39;@cycle/core&#39;
import panesCount from &#39;./models/panes-count&#39;
import sheetGroup from &#39;./models/sheet-group&#39;
import sheetGroups from &#39;./models/sheet-groups&#39;
import sheets from &#39;./models/sheets&#39;

export default function (actions) {
  return Rx.Observable.combineLatest(
    panesCount(actions),
    sheetGroup(actions),
    sheetGroups(actions),
    sheets(actions),
    (...objects) =&gt; _.extend(...objects)
  );
}</pre>


<h2>view.js</h2>

<p>viewだけは同じ型の小さなviewには分割されない。代わりに、templatesディレクトリ以下にtemplate関数を返す<a class="keyword" href="http://d.hatena.ne.jp/keyword/%CA%A3%BF%F4">複数</a>のファイルを用意して分割するようにしている。template関数は「Objectを受け取り、VirtualDOMを返す関数」として定義してある。ただのテンプレート関数。</p>

<pre class="code" data-lang="" data-unlink>import root from &#39;./templates/root&#39;

export default function (state$) {
  return state$.map(root);
}</pre>


